31 instructions

-  created in 1977 by Joe weisbecker for cosmic vip microcomputer
- purpose: simpler way to write programs for the computer
- instead of machine code use higher level hex instructions that resembles machine code and where interpreted on the fly by the chip-8 emulator/interpretor
- 

CHIP-8 has the following components:

    Memory: CHIP-8 has direct access to up to 4 kilobytes of RAM

    Display: 64 x 32 pixels (or 128 x 64 for SUPER-CHIP) monochrome, ie. black or white

    A program counter, often called just “PC”, which points at the current instruction in memory
    
    One 16-bit index register called “I” which is used to point at locations in memory
    
    A stack for 16-bit addresses, which is used to call subroutines/functions and return from them
    
    An 8-bit delay timer which is decremented at a rate of 60 Hz (60 times per second) until it reaches 0
    
    An 8-bit sound timer which functions like the delay timer, but which also gives off a beeping sound as long as it’s not 0
    
    16 8-bit (one byte) general-purpose variable registers numbered 0 through F hexadecimal, ie. 0 through 15 in decimal, called V0 through VF
        
        VF is also used as a flag register; many instructions will set it to either 1 or 0 based on some rule, for example using it as a carry flag



Chip8 programs assumed to be loaded at 0x200 (normally big endian fashion ie most significant byte stored first)

16 8-bit general purpose registers, unsigned integer 0-255, 00-FF, referred to as V0-VF


-> VF sometimes used by instructions as a flag be cautious 

---- 6XNN - store number NN in register VX
---- 8XY0 - store value of VY in VX
---- 7XNN - store the value NN to VX (regster wraps around when overflows mod 255)
---- 8XY4 - VX = VX + VY, set VF=01 if carry else 0
---- 8XY5 - VX = VX - VY, set VF=00 if borrow else 01
---- 8XY7 - VX = VY - VX, same
---- 8XY2 - VX = (VX and VY)
---- 8XY1 - VX = (VX or VY)
---- 8XY3 - VX = (VX xor VY)
---- 8XY6 - VX = (VY << 1), set VF - least significant bit to prior shift (out of bounds)
---- 8XYE - VX = (VY >> 1), set VF = most significant same stuff
---- CXNN - VX = (random(00,FF) and NN)
---- 1NNN - jump to NNN
---- BNNN - jump to NNN+V0
---- 2NNN - exec subroutine at NNN (space for 12 successive calls on go but can code more)
---- 00EE - return from subroutine
---- 0NNN - exec machine language subroutine at NNN (deprecated usually not implemented)
-------- here machine code end is indicated by byte D4 to return control to chip 8
---- 3XNN - skip instruction if VX = NN
---- 5XY0 - skip ins if VX = VY
---- 4XNN skip ins if VX != NN
---- 9XY0 - skip ins if VX != VY
---- FX15 - set delay timer = VX
---- FX07 - store current delay timer in VX
---- FX18 - set sound timer to val in reg VX ( in cosmic vip manual min val is 02)
---- FX0A - wat for keypress and store result in VX (halts all)
---- EX9E - skip following instruction if key equals VX hex value is pressed
---- EXA1 - skip ins if key equals VX not pressed
---- ANNN - store memory address in register I
---- FX1E - I = I + VX (can't be modified by arithmetic instruction)
---- DXYN - draw sprite at pos VX, VY with N bytes of sprite data starting at address in I, set VF = 1 if any pixels changed to unset else 00, VX between 00.3F, vY in 00-1F, then N bytes are read start at I
---- 00E0 - clear screen
---- FX29 - set I to mem adder of sprite data corresponding to hexadecimal digit stored in reg VX
---- FX23 - store binary coded equivalent of val in VX ti I,I+1,I+2 for each digit of 8 bt number
---- FX55 - store values of registers V0 to VX inclusive in memory starting at address I, I is set to I+X+1 after operation
---- FX65 - fill registers V0 to VX with the values stored in memory starting at address I, I is set to I+X+1 after operation


- first chip interpreter located in ram from 000-1FF 

- monochrome graphics, 64x32, default black, sprites for drawing (8 pixels wide, 1-15 piles high), stored in memory, one byte one row of sprite, cautious sprite data not executed, should place sprite data in beginning of program and proceeded by a jump instruction; or at end of program and make interpreter not able to reach that section


- chip-8 og implemented on rca cosmac vip
Ex: 8XX6 shifts X itself a bit to the left